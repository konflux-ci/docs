= Creating applications and components

== Onboarding components to {ProductName}

{ProductName} supports two methods for creating applications and components:

* With the UI
* With the CLI

Applications in Konflux are simply logical groupings of components. So to create an application, you must first create at least one component. 

Before being able to onboard a component to {ProductName}, you need to ensure that the instance has appropriate access to the git repository. This means either installing your organization’s {ProductName} GitHub App on the source code repository or xref:building:creating-secrets.adoc#creating-source-control-secrets[creating a secret] to enable access to a GitLab repository.

NOTE: All resource names (like Applications and Components) must be unique in a namespace, even when the same resource is used in different applications.

CAUTION: {ProductName} pushes directly to branches in your onboarded repositories. In order to properly onboard, you need to ensure
that no rules prevent pushes to the branch patterns *`konflux-*`* and *`konflux/mintmaker/*`*.

=== Creating applications and components with the UI

.Prerequisites:

* xref:installing:enabling-builds.adoc[Enabled build pipelines] for your instance of {ProductName}.
* xref:installing:enabling-builds.adoc#enable-image-controller[Enabled image controller] for your instance of {ProductName}.

==== Create initial application and component

.*Procedures*

. In the {ProductName} UI, go to the *Applications* page.
. Click the *Create application* button.
. Enter a name for the application.
. Click the *Add a component* button.
+

NOTE: For *Gitlab* provider, make sure to xref:building:creating-secrets.adoc#creating-source-control-secrets[create a source control secret] before creating the component.
  . Enter the URL for the git repository.
  . (Optional) After clicking out of the repository URL, expand the *Show advanced Git options*.
    . Enter the branch name to the *Git reference* dialogue.
    . Enter the path to the context directory if the build context is contained somewhere other than the repository root.
  . Enter the path to the Dockerfile within the git repository. This will be the path within the context directory.
  . (Optional) Change the component name if desired.
  . (Optional) Click on the *Pipeline* drop down box and select the desired pipeline to configure your component with.
  . (Optional) Click on *Add secret* to add a secret which will be needed for the component build. See xref:building:creating-secrets.adoc[creating secrets] for more information.
. Click *Create application*.

+
NOTE: GitHub and GitLab are supported source control providers. GitLab support requires the configuration of xref:building:creating-secrets.adoc#creating-source-control-secrets[source control secrets].

NOTE: When an application or component is immediately removed after creation, the action might result in an orphaned ImageRepository where ownership
was not yet assigned to the resource. When you try to create the resource again with the same name, the UI will send an error message that the ImageRepository already exists. The solution is to manually remove ImageRepository from OCP.

==== Create additional components in an application

.*Procedures*

. In the {ProductName} UI, go to the *Applications* page.
. Click on the name of the application that you want to add a component to.
. Click on *Actions* and *Add component*.
. Follow the procedure above for specifying the component.
. Click *Add component*.

=== Creating applications and components with the CLI

.Prerequisites:

* xref:installing:enabling-builds.adoc[Enabled] build pipelines for your instance of {ProductName}.
* link:https://kubernetes.io/docs/tasks/tools/[kubectl] CLI tool
* You have completed the steps listed in the xref:ROOT:getting-started.adoc#getting-started-with-the-cli[Getting started in the CLI] page.

.*Procedures*

. Create an `Application.yaml`, `Component.yaml`, and `ImageRepository.yaml` files locally.

+
*Example `Application.yaml` object*
+
include::partial$custom-resources/{context}-application.adoc[]

+
*Example `Component.yaml` object*
+
include::partial$custom-resources/{context}-component.adoc[]

+
*Example `ImageRepository.yaml` object*
+
include::partial$custom-resources/{context}-imagerepository.adoc[]

. In your tenant namespace, save the `Application.yaml`, `Component.yaml`, and `ImageRepository.yaml` files and add the resource to your cluster by running the following command:

+
[source,shell]
----
$ kubectl apply -f Application.yaml -f Component.yaml -f ImageRepository.yaml
----

+
NOTE: You can create additional components and applications with the same file locally by adding additional custom resource configurations. 

. Now, you can trigger your application’s first build pipeline. In the git repository for your application, using your preferred text editor, open a pull request against the `/.tekton/pull-request.yaml` file. 
+

Specifically, replace any existing value for the `git-url` field with the git URL for your application’s repository. (This is the URL you would use to clone the repository locally; it ends with `.git`.)

+
NOTE: The PipelineRun will run only for submitters who have permission to run PipelineRuns or who receive an `/ok-to-test` comment from an authorized user. +
For further details on PipelineRun permissions, please refer to the https://pipelinesascode.com/docs/guide/running/[PipelinesAsCode documentation].

. Once the PR is made, a build pipeline should start. You can track its progress in the {ProductName} UI or you can see the final status in GitHub after the pipeline completes. If the pipeline is successful, you can merge the PR.

== Using a custom image repository

When using the ImageRepository object, you will end up with an image repository in
a default organization. If you want to use your own repository
don't create the ImageRepository object. Instead, use the following procedure.

.*Procedure*

. Create your own repository in quay.io (or another other registry. This example is for quay.io.

. In quay.io web UI, go to your organization and click on *Create New Repository*, enter the repository name
and visibility, and click on *Create Public/Private Repository*.For example, enter `quay.io/ test_organization/own-repository`

. Create a robot account in your organization and grant write permission to your repository. You can also create another robot account with only read permissions.

. In the quay.io web UI, go to your organization, click on *Robot Accounts* in the left menu,
then click on *Create Robot Account*. 
. Enter the name of the robot account and click on the *Create robot account* button. 
. In the list of repos, find your repository and set *write* permission for it, and then click on the *Add permissions* button.
+

When you click on the newly created robot account on *Robot Accounts* page, you can get details of the account.

. In the opened popup for the account, first you will see the credentials *Username* and *Token* (take note of these as they will be used later).

. Click on *Kubernetes Secret* to download a secret yaml file (it will be used later in this procedure).

Next, you have to create secret with repository credentials.

=== Creating a Secret via {ProductName} UI

.*Procedure*

. xref:building:creating-secrets.adoc#example-of-creating-a-quay-io-secret[Create a secret] with the credentials above.
+

Make sure to use the most narrowly valid scope for the `registry server address` field
when adding the secret.
+

When adding the secret (image registry) with the UI, you have to choose components to which component-specific
service accounts `build-pipeline-$COMPONENT_NAME` the secret will be linked to. You do this so that the secret can be leveraged by builds.

=== Creating a Secret manually

If you aren't using quay.io registry and have only a login and password, you have to use a podman login
with credentials, and then get the docker config json from  `$XDG_RUNTIME_DIR/containers/auth.json`, base64 encode it,
and add it to the secret.

.*Procedure*

. Download the secret yaml for your robot account (from the *Robot Accounts* page described above)
and save it as `Secret.yaml`.

Here is an example file:

[source,yaml]
----
apiVersion: v1
kind: Secret
metadata:
  name: secret-name
data:
  .dockerconfigjson: <base64-encoded-credentials>
type: kubernetes.io/dockerconfigjson
----

[start=2]
. Edit the file and add `metadata.namespace` with the value of your namespace: `<your-tenant>`
+

Encoded credentials from quay.io will be by default for the `quay.io` repository. 

. If you are using only a custom repository
for the whole namespace, a robot account for all repos, and have only one secret in the namespace for the registry, change the repository in the encoded credentials
from `quay.io` to `quay.io/test_organization/own-repository`.

. To get new <base64-encoded-credentials> follow these steps:

.. Decode encoded credentials and save them to a file: `echo <base64-encoded-credentials> | base64 -d > auth.json`

Here is an example file:

[source,json]
----
{
  "auths": {
    "quay.io": {
      "auth": "<base64-encoded-auth>",
      "email": ""
    }
  }
}
----

[start=2]
.. Edit the file and change `quay.io` to full repository name `quay.io/test_organization/own-repository`.

.. Encode the credentials again: `cat auth.json | base64 -w0`
and change `<base64-encoded-credentials>` to the newly generated credentials in `Secret.yaml`. 

.. Create the secret:

[source,shell]
----
$ kubectl apply -f Secret.yaml
----

[start=5]
.. Link the secret to the component-specific service account `build-pipeline-$COMPONENT_NAME`,
edit the service account either with OCP UI or the CLI, and to the `secrets` section of the service account
add your newly created secret. The service account should look like the following example:

[source,yaml]
----
kind: ServiceAccount
apiVersion: v1
metadata:
  name: build-pipeline-$COMPONENT_NAME
  namespace: <your-tenant>
secrets:
  - name: secret-name
----

=== Creating the component that uses your own repository

Now that you have created a secret with credential to your own repository, you can create a component using it.

Follow the examples in the previous subsections on how to create a component using the CLI, but now you have to set `spec.containerImage` to your own repository `quay.io/test_organization/own-repository`.

== Finding the built images

After a pipeline completes with a built artifact, you may want to test the resulting image to ensure that it works properly. The `IMAGE_URL` Tekton result (discoverable from the UI or CLI) should be set to the pullspec for the image.

CAUTION: {ProductName} automatically deletes images built for PR pipelines five days after building them.

=== With the UI

All build PipelineRuns are visible in the {ProductName} UI. The location of these images in the OCI registry is reported on the *Activity* page.

.*Procedure*

In the console, complete the following steps to find the image pullspec for a completed PipelineRun:

. Navigate to the *Activity* > *Pipeline runs* tab.

. For the component whose SBOM you want to view, select its most recent pipeline run.

. Find the *Results* section at the bottom of the page and look for the `IMAGE_URL` row. It should resemble `quay.io/redhat-user-workloads/your-tenant/application/component:tag`. You can use the `IMAGE_DIGEST` provided as an alternate mechanism for referencing the image.

=== With the CLI

After the build PipelineRuns are completed from git push events, the Components are updated with the location of the artifact in the OCI registry.

.Prerequisites

* xref:ROOT:getting-started.adoc#getting-started-with-the-cli[Login] to {ProductName}.

* Install the link:https://stedolan.github.io/jq/download/[jq] CLI tool.

.*Procedure*

In the CLI, complete the following steps to find the latest pullspec for a component:

. List your components.
+
[source]
----
$ kubectl get components
----
+
.Example output
+
[source]
----
NAME                               AGE   STATUS   REASON   TYPE
devfile-sample-go-basic-8wqt       8m54s True     OK       Updated
devfile-sample-python-basic-ikch   20d   True     OK       Updated
----

. Choose which component's image you want to discover. Then use `kubectl get` and the `jq` CLI tool to get the component image path.

+
[source]
----
$ kubectl get component <component name> -o json | jq '.status.containerImage'
----

. For convenience, you may want to save the image path to a local variable.
+
Example:
+
[source]
--
IMAGE=quay.io/redhat-user-workloads/your-tenant/application/component@sha256:<output omitted>
--
