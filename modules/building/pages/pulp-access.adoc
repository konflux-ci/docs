= Getting Access to Pulp Storage

Pulp is our artifact storage system for everything that's not a container image. Think RPMs, Python wheels, Go modules, generic files - basically any build artifact that doesn't belong in an OCI registry. While container images go to Quay, everything else should land in Pulp.

If you're building RPMs or publishing Python packages, you'll want to set up Pulp access in your namespace. It's pretty straightforward.

== What you get

When you create a `PulpAccessRequest`, the controller sets up:

* A secret called `pulp-access` with pre-configured CLI settings
* A dedicated Pulp domain (named `konflux-<your-namespace>`)
* mTLS authentication using your certificates
* Optionally, Quay.io as an OCI storage backend if you need it

The secret includes everything your builds need to push artifacts to Pulp. No manual configuration required.

== Basic setup

First, you need a TLS certificate and key. Create a secret with them:

[source,yaml]
----
apiVersion: v1
kind: Secret
metadata:
  name: my-pulp-creds
  namespace: my-namespace
type: Opaque
stringData:
  cert: |
    -----BEGIN CERTIFICATE-----
    MIIDXTCCAkWgAwIBAgIJAKJ...
    -----END CERTIFICATE-----
  key: |
    -----BEGIN PRIVATE KEY-----
    MIIEvgIBADANBgkqhkiG9w0BA...
    -----END PRIVATE KEY-----
----

Then create a `PulpAccessRequest`:

[source,yaml]
----
apiVersion: pulp.konflux-ci.dev/v1alpha1
kind: PulpAccessRequest
metadata:
  name: my-pulp-access
  namespace: my-namespace
spec:
  credentialsSecretName: my-pulp-creds
----

The controller will create a domain called `konflux-my-namespace` in Pulp and generate the `pulp-access` secret with everything configured.

== Certificate naming

The controller is flexible about how you name things in your credentials secret. You can use either:

* `cert` and `key` (shown above)
* `tls.crt` and `tls.key` (if you're copying from a TLS secret)

Both work the same way.

== Using it in builds

Once the secret is created, you can mount it in your build pods. Here's an example of using it in an RPM build pipeline:

[source,yaml]
----
- name: rpmbuild-and-push
  image: quay.io/fedora/fedora:latest
  script: |
    #!/bin/bash
    set -e
    
    # Build your RPM
    rpmbuild -ba mypackage.spec
    
    # Configure pulp-cli from the mounted secret
    export PULP_CLI_CONFIG=/workspace/pulp-config/cli.toml
    export PULP_CERT=/workspace/pulp-config/tls.crt
    export PULP_KEY=/workspace/pulp-config/tls.key
    
    # Upload to Pulp
    pulp rpm upload ~/rpmbuild/RPMS/x86_64/*.rpm
  volumeMounts:
  - name: pulp-config
    mountPath: /workspace/pulp-config
    readOnly: true
volumes:
- name: pulp-config
  secret:
    secretName: pulp-access
----

The secret includes a `cli.toml` file that's already configured with your domain and mTLS settings, so you don't need to write any config yourself.

== Python packages example

For Python packages, it's similar:

[source,bash]
----
# Build your wheel
python -m build

# Configure pulp-cli
export PULP_CLI_CONFIG=/workspace/pulp-config/cli.toml
export PULP_CERT=/workspace/pulp-config/tls.crt
export PULP_KEY=/workspace/pulp-config/tls.key

# Upload to Pulp
pulp python content upload dist/*.whl
----

== With Quay backend (advanced)

If you want Pulp to store container images using Quay as the backend, add `use_quay_backend: true`:

[source,yaml]
----
apiVersion: pulp.konflux-ci.dev/v1alpha1
kind: PulpAccessRequest
metadata:
  name: pulp-with-quay
  namespace: my-namespace
spec:
  credentialsSecretName: my-pulp-creds
  use_quay_backend: true
----

This creates an ImageRepository and wires up Quay for OCI storage. Most people won't need this - it's mainly useful if you're doing something custom with container image workflows through Pulp.

== Checking if it worked

After creating the PulpAccessRequest, check if it's ready:

[source,bash]
----
kubectl get pulpaccessrequest my-pulp-access -o yaml
----

Look for the status section. If `conditions` shows `Ready: True`, you're good to go. The status also tells you:

* `domain`: The Pulp domain that was created
* `domainCreated`: Whether the domain creation succeeded
* `secretName`: Name of the generated secret (always `pulp-access`)

Quick check:

[source,bash]
----
kubectl get pulpaccessrequest my-pulp-access -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}'
----

If it prints `True`, everything's set up.

== Common gotchas

**Secret not found**: Make sure your credentials secret exists in the same namespace before creating the PulpAccessRequest.

**Domain creation fails**: Your TLS certificate needs proper permissions for the Pulp API. Check with your platform team if you're not sure.

**Can't find the pulp-access secret**: It's created in the same namespace as your PulpAccessRequest. If you're looking in a different namespace, you won't see it.

**Build can't authenticate**: Double-check that you're mounting the secret correctly and setting the environment variables (`PULP_CLI_CONFIG`, `PULP_CERT`, `PULP_KEY`).

== Why use Pulp?

If you're wondering why we're pushing non-container artifacts to Pulp instead of keeping them local or using random file storage:

* **Centralized storage**: All your artifacts in one place, easy to track and manage
* **Versioning**: Pulp keeps track of different versions of your artifacts
* **Access control**: Proper authentication and domain isolation
* **Distribution**: Built-in content delivery for your artifacts
* **Multi-format support**: RPMs, Python wheels, generic files, and more

For anything that's not a container image, Pulp should be your default choice.
