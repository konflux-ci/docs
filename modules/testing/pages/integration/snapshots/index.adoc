= Snapshots

// Optional: Define context for cross-references if needed within the module structure
// :context: snapshots

A {ProductName} **Snapshot** represents a specific, immutable collection of container images for the Components within an Application at a particular point in time. They capture the exact versions of all relevant component artifacts that were built and intended to be used together including their Git commits. Once created, the list of Components with their images is immutable. 

Snapshots are fundamental for ensuring consistency during testing and release processes. They provide a stable target for:

* Running integration tests defined by IntegrationTestScenarios (ITS). The Integration service updates the status of the resources to reflect the testing outcomes.
* Creating Releases using ReleasePlans to promote a specific set of component versions to different environments (like staging or production).

== Example Snapshot

Example Snapshot resource contents::
[source]
----
apiVersion: appstudio.redhat.com/v1alpha1
kind: Snapshot
metadata:
  name: snapshot-sample <.>
  namespace: ws-sample-tenant <.>
spec:
  application: application-sample <.>
  components:
    - name: component-sample <.>
      containerImage: quay.io/redhat-user-workloads/ws-sample-tenant/application-sample/component-sample@sha256:0db0a473a6abf5c15c424ab07cfbd5c40c06622fe648d4fe6a6b6abc224a0d0c <.>
      source: <.>
        git:
          url: https://github.com/sample-org/sample-repo
          revision: fa8b89274a61ef0f1c257b7a84c37aa2ec844109
----
<.> The name of the Snapshot resource.
<.> The namespace where the Snapshot exists. It should correspond to the user's tenant namespace.
<.> The Application that the Snapshot belongs to.
<.> The name of the individual Component of the Application.
<.> The full image pull specification for the container image. The images need to be referenced by digest.
<.> The component source containing the git URL and revision that the component's container image was built from.

== Snapshot Creation

Snapshots can be generated in several ways:

* **Automatic (Push Events):** This is the primary mechanism for generating snapshots intended for release pipelines.
** When code is pushed to a branch tracked by your Components (e.g., `main`, `release-4.19`), {ProductName} triggers the associated build pipelines defined in the `.tekton/` directory of your component repositories.
** Once the build is complete, a Snapshot CR is automatically created. It contains references to the container image digest produced by that successful build along with the latest images for all other Components in the Application.
** These push-event snapshots are typically labeled with `pac.test.appstudio.openshift.io/event-type=push`. Snapshots without `pac.test.appstudio.openshift.io/event-type` or `pac.test.appstudio.openshift.io/pull-request` annotations are treated as push snapshots.
** They may be used for xref:releasing:create-release.adoc[creating a release].

* **Automatic (Pull Request Events):** Snapshots are also generated for Pull Requests (PRs) to enable automated testing of proposed changes.
** Once a pull or merge request build is complete, a Snapshot CR is automatically created. It contains references to the container image digest produced by that successful build along with the latest push images for all other Components in the Application.
** These pull request-event snapshots are typically labeled with `pac.test.appstudio.openshift.io/event-type=pull_request`.
** These snapshots might be created incrementally constructed as individual component builds finish within the PR context (i.e. xref:testing:integration/snapshots/group-snapshots.adoc[group snapshots]). These group snapshots are often annotated with `test.appstudio.openshift.io/pr-group`.
** Pull request Snapshots are subject to more aggressive garbage collection policies (see below).
** They are primarily intended for pre-merge testing and usually not used for formal releases.

* **Manual:** You can xref:testing:integration/snapshots/working-with-snapshots.adoc#manual-snapshots[manually create] a Snapshot custom resource (CR) if needed. This allows you to define a specific combination of existing component container images (e.g., previously built images stored in `quay.io`) for testing or release purposes. This is useful for scenarios like promoting a specific known-good set of images to production when automatic releases are disabled.

== Quotas and Garbage Collection

Understanding how Snapshots are managed and limited within {ProductName} is essential to avoid unexpected behavior:

=== Snapshot Quota

* There is a resource quota limiting the total number of Snapshot CRs that can exist within a single tenant namespace.
* The default quota is **1024 Snapshots** (`count/snapshots.appstudio.redhat.com`).

[IMPORTANT]
====
This quota is **not user-configurable**. If you anticipate exceeding this limit due to a large number of applications or frequent builds across many supported versions, you may need to contact the {ProductName} administrators to request a quota increase for your namespace.

Monitor usage via `kubectl get quota appstudio-crds-integration -o yaml`.
====

=== Snapshot Garbage Collection (GC)

Snapshot CRs themselves consume resources. To manage this and stay within quota, {ProductName} implements automated garbage collection:

* **Mechanism:** GC is based on **retention counts**, not age. {ProductName} keeps a specific number of the most recent Snapshots and deletes the oldest ones beyond that limit.
* **Eligibility:** GC only deletes Snapshots that are **not** referenced by an active `Release` CR.
* **Per-Component Preservation:** To handle applications where components have different build, test, or release cadences, the garbage collector preserves the latest **5** push snapshots per component that are not associated with a `Release` CR. This ensures that snapshots for less frequently built components remain available for manual release, even if other components build more frequently.
* ** Default retention counts:**
*** **~=640** non-PR (push event) snapshots. This includes both Snapshots that are referenced by a `Release` CR and those that are not.
*** **70** PR event snapshots.
* **Exception:** Snapshots annotated with `test.appstudio.openshift.io/keep-snapshot=true` will not be garbage collected, but they still count towards the retention count.

IMPORTANT: These retention counts are **not user-configurable**.

[NOTE]
====
It's possible to encounter a situation where new unreferenced Snapshots are getting deleted very quickly - possibly within a day or two.

**Cause**: This can occur when a large number of Snapshot CRs are protected from count-based GC by active Release CRs. While these Snapshots are protected, they still count towards the global quota and retention counts. If there is a significant number of new builds in the namespace, the reduced space in the retention pool can cause unreferenced Snapshots to be deleted very quickly.

**Mitigation**: The primary way to prevent this is to manage the lifecycle of your Release CRs.

**Configure the Grace Period**: Ensure the gracePeriodDays field for your Releases is set to a reasonable value that reflects your team's release cadence. This can be configured in your ReleasePlan and will be applied to created Release CRs. If gracePeriodDays is not set in your Release, KubeArchive will delete it when it is 5 days old. KubeArchive will also delete any Release more than 30 days old, regardless of the gracePeriodDays value. A shorter grace period ensures Release CRs are deleted more quickly, freeing up their associated Snapshots for garbage collection.

**Manual Deletion**: In an urgent situation, you can manually delete old or unnecessary Release CRs to immediately make their Snapshots eligible for GC. 
====

=== Relationship with Releases

* When you create a `Release` CR from a Snapshot, that Snapshot is protected from the count-based garbage collection described above *if the Release exists*.
* `Release` CRs have their own time-based expiration and automatic cleanup:
** The retention period is defined by the `gracePeriodDays` field in the Release spec. This can be configured in the xref:releasing:create-release-plan.adoc[`ReleasePlan`] and will be applied to created Releases.
** If `gracePeriodDays` is not set in your Release, KubeArchive will delete it when it is 5 days old.
** KubeArchive will also delete any Release more than 30 days old, regardless of the `gracePeriodDays` value.
** Deleted Releases are archived and remain accessible via the KubeArchive API for historical access and auditing.
* When a Release CR is automatically deleted by KubeArchive, its associated Snapshot CR is no longer protected and becomes eligible for count-based garbage collection if the retention limits are exceeded.

[NOTE]
====
The garbage collection of `Snapshot` and `Release` CRs does **not** automatically delete the underlying container images that were pushed to registries.

* Images pushed to `quay.io` during **PR builds** typically expire automatically (default: 5 days, configurable in the pipeline with the `image-expires-after` parameter).
* Images pushed to `quay.io` during **push builds** do **not** expire automatically but *will* be deleted if the corresponding `Component` CR is deleted (unless repository deletion is xref:building:imagerepository.adoc#skip-repository-deletion[explicitly skipped]).
* Images promoted to external registries via a release pipeline are **not** deleted by {ProductName} GC.
====

== Understanding Incomplete Snapshots

A common point of confusion occurs when a Snapshot contains fewer components than expected (e.g., only 1 out of 5 components in an Application).

* **Cause:** A Snapshot accurately reflects the state of *successfully completed* component builds *at the time it was created*. If components are missing, it usually means their corresponding build pipelines either:
..  Were not triggered correctly by the `push` event.
..  Failed to complete successfully before the Snapshot was generated.
* **Troubleshooting:** If you encounter incomplete push-event snapshots:
** Verify the build `PipelineRun` status for *all* expected components associated with that push event.
** Examine the pipeline trigger configuration, specifically the `pipelinesascode.tekton.dev/on-cel-expression` annotation in the `.tekton/` pipeline definitions within each component's repository. Ensure the expression correctly targets the intended branch (e.g., `event.ref == refs/heads/release-4.19`) and includes the necessary conditions (e.g., relevant file paths changed) to trigger builds when expected. Misconfigurations here are a common cause of components not building and thus being absent from the Snapshot.

== Further Reading

* To learn how to interact with snapshots using the CLI or UI, see xref:testing:integration/snapshots/working-with-snapshots.adoc[Working with Snapshots].
* To learn how to reset the latest component references for future Snapshots, see xref:testing:integration/snapshots/override-snapshots.adoc[Creating an override snapshot].
* To learn more about group Snapshots, see xref:testing:integration/snapshots/group-snapshots.adoc[Creating a group snapshot].
* To learn how to release a Snapshot, see xref:releasing:create-release.adoc[Creating a release].
* For details on the Snapshot API resource, refer to the xref:reference:kube-apis/application-api.adoc#k8s-api-github-com-konflux-ci-application-api-api-v1alpha1-snapshot[Snapshot API Reference].
